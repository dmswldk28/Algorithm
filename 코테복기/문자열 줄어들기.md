# 문자열 줄어들기 추적 문제

## 📌 문제 설명
- 알파벳 소문자로 이루어진 문자열 배열 `strs`가 주어진다.  
- `strs[i]` 는 항상 `strs[i-1]`에서 **특정 문자를 줄이는 연산**을 통해 만들어진다.  
- 문자가 줄어드는 경우는 다음과 같다:
  1. 특정 문자 **하나만** 제거
  2. 특정 문자 **모두** 제거
  3. 어떤 경우인지 **모호**한 경우

---

## 📌 출력 규칙
- `"1x"` : 문자 `x`가 정확히 **1개 줄어든 경우**
- `"2x"` : 문자 `x`가 **여러 개 → 0개**로 전부 사라진 경우
- `"?x"` : 문자 `x`가 **1개였다가 사라져서(1→0)** 전부인지 하나인지 알 수 없는 경우

---

## 📌 예시

```text
입력:
["aabbcc", "abbcc", "acc", "c"]

변화 과정:
aabbcc → abbcc   : 'a' 1개 제거 → "1a"
abbcc  → acc     : 'b' 전부 제거 → "2b"
acc    → c       : 'a' 1개 있었는데 사라짐 → "?a"

출력:
["1a", "2b", "?a"]
````

---

## 📌 풀이 아이디어

1. `strs[i-1]` 과 `strs[i]` 의 문자 개수를 비교한다.
2. 차이가 나는 문자를 찾는다.
3. 줄어든 개수와 남은 개수를 기반으로 규칙을 적용한다:

   * `(before - after == 1 && after > 0)` → `"1x"`
   * `(after == 0 && before > 1)` → `"2x"`
   * `(after == 0 && before == 1)` → `"?x"`

---

## 📌 Java 코드

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        String[] strs = {"aabbcc", "abbcc", "acc", "c"};
        List<String> result = solve(strs);
        System.out.println(result);
    }

    public static List<String> solve(String[] strs) {
        List<String> result = new ArrayList<>();

        for (int i = 1; i < strs.length; i++) {
            String prev = strs[i - 1];
            String curr = strs[i];

            // 문자 개수 카운팅
            int[] countPrev = new int[26];
            int[] countCurr = new int[26];

            for (char c : prev.toCharArray()) {
                countPrev[c - 'a']++;
            }
            for (char c : curr.toCharArray()) {
                countCurr[c - 'a']++;
            }

            // 차이가 발생한 문자 찾기
            char diffChar = 0;
            for (int j = 0; j < 26; j++) {
                if (countPrev[j] != countCurr[j]) {
                    diffChar = (char)(j + 'a');
                    break; // 항상 한 문자만 줄어든다고 가정
                }
            }

            int before = countPrev[diffChar - 'a'];
            int after = countCurr[diffChar - 'a'];

            if (before - after == 1 && after > 0) {
                result.add("1" + diffChar);
            } else if (after == 0 && before > 1) {
                result.add("2" + diffChar);
            } else if (after == 0 && before == 1) {
                result.add("?" + diffChar);
            } else {
                result.add("?" + diffChar); // 예외 처리
            }
        }
        return result;
    }
}
```

---

## 📌 시간 복잡도

* 문자열 길이를 `m`, 문자열 개수를 `n`이라 하면
  각 단계마다 문자 개수 비교(`O(m)`) × `n-1`번 반복 → `O(n*m)`
* 문제 조건(`n, m ≤ 500`)에서 충분히 효율적이다.
