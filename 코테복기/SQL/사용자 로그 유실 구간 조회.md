## 사용자 로그 유실 구간 조회

### 문제 설명
- `USER_LOGS` 테이블이 주어짐.
- 각 사용자는 `LOG_ID`가 `1`부터 시작하여 1씩 증가하는 형태로 로그를 기록함.
- 하지만 중간에 유실된 로그들이 존재할 수 있음.
- 목표: **각 사용자(`USER_ID`)별로 가장 먼저 유실된 `LOG_ID`를 찾기**

- 출력 컬럼:
  - `USER_ID` : 사용자 ID
  - `MISSING_LOG_ID` : 가장 먼저 유실된 로그 ID  
    - 만약 유실된 로그가 없다면 → `MAX(LOG_ID) + 1`

---

### 테이블 예시

**USER_LOGS 테이블**

| USER_ID | LOG_ID |
|--------:|-------:|
| 1       | 1      |
| 1       | 2      |
| 1       | 4      |
| 2       | 2      |
| 2       | 3      |
| 3       | 1      |
| 3       | 2      |
| 3       | 3      |
| 3       | 4      |

---

### 출력 예시

| USER_ID | MISSING_LOG_ID |
|--------:|----------------|
| 1       | 3              |
| 2       | 1              |
| 3       | 5              |

---

### SQL 풀이 아이디어
1. 사용자별(`USER_ID`)로 `LOG_ID`를 정렬하고 `LAG()`를 이용해 이전 로그값을 비교
2. `현재 LOG_ID - 이전 LOG_ID > 1`인 지점 → **유실된 값 = 이전 LOG_ID + 1**
3. 첫 로그가 1이 아닌 경우 → 유실된 값 = 1
4. 유실된 값이 없으면 `MAX(LOG_ID) + 1`

---

### SQL 예시 코드

```sql
WITH x AS (
    SELECT 
        user_id,
        log_id,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY log_id) AS expected_id
    FROM user_logs
),
missing AS (
    -- log_id 와 expected_id 가 다르면 → 그 expected_id 가 바로 유실된 로그 번호
    SELECT user_id, expected_id AS missing_log_id
    FROM x
    WHERE log_id <> expected_id
),
fallback AS (
    -- 유실이 없다면 → 마지막 번호 + 1
    SELECT user_id, MAX(log_id) + 1 AS missing_log_id
    FROM user_logs
    GROUP BY user_id
)
SELECT 
    f.user_id,
    COALESCE(MIN(m.missing_log_id), f.missing_log_id) AS missing_log_id
FROM fallback f
LEFT JOIN missing m ON f.user_id = m.user_id
GROUP BY f.user_id
ORDER BY f.user_id;
```
