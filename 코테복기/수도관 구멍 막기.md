## 수도관 구멍 테이프로 막기

### 📌 문제 설명

* 수도관에 구멍이 `n`개 뚫려 있다.
* 길이가 `tape`인 방수 테이프 하나가 있다.
* 이 테이프를 잘라서 여러 조각으로 사용할 수 있으며,
  길이 `k`짜리 조각은 `[x, x+k-1]` 범위를 덮을 수 있다.
* 모든 구멍을 막기 위해 필요한 **최소 조각 수**를 구하라.

---

### 📌 제약 조건

* `2 <= n <= 100000`
* `1 <= holes[i] <= 100000000`
* `holes`는 오름차순 정렬, 중복 없음
* `1 <= tape <= 100000000`

---

### 📌 예시

| holes           | tape | result |
| --------------- | ---- | ------ |
| \[1,3,8,10,11]  | 8    | 2      |
| \[3,7,17]       | 15   | 1      |
| \[1,6,10]       | 3    | 3      |
| \[1,2,4,5,8,10] | 8    | 2      |

---

### 📌 풀이 아이디어
* **Simple Is The Best**
> 대대권
---

### 📌 Java 코드

```java
import java.util.Arrays;

class Solution {
    public int solution(int[] holes, int tape) {
        int n = holes.length;
        if (n <= 1) {
            return n;
        }

        // 1. 인접한 구멍 사이의 간격(빈 공간)을 계산
        int[] gaps = new int[n - 1];
        for (int i = 0; i < n - 1; i++) {
            gaps[i] = holes[i + 1] - holes[i] - 1;
        }

        // 2. 간격을 오름차순으로 정렬
        Arrays.sort(gaps);

        // 3. 전체 구멍을 덮는 데 필요한 초기 길이
        long totalLength = (long)holes[n - 1] - holes[0] + 1;
        
        // 4. 초기 조각 수 (하나의 조각)
        int minPieces = 1;

        // 5. 가장 긴 간격부터 제거하여 필요한 총 길이를 줄임
        //    간격을 하나 제거할 때마다 조각의 수는 1씩 증가함
        for (int i = n - 2; i >= 0; i--) {
            // 남은 길이가 tape보다 작거나 같아지면 멈춤
            if (totalLength <= tape) {
                break;
            }
            // 가장 긴 간격을 제거하고, 필요한 조각 수를 증가시킴
            totalLength -= gaps[i];
            minPieces++;
        }

        return minPieces;
    }
}
```

---

### 📌 시간 복잡도
- O(N log N)
- 인접한 구멍 사이의 간격을 계산하는 부분: O(N)
- 간격 배열을 정렬하는 부분: O(N log N)
- 정렬된 간격 배열을 순회하며 결과를 찾는 부분: O(N)
- 전체 시간 복잡도는 정렬 과정에 의해 O(N log N)이 됩니다.
- N의 최대값이 100,000이므로, 100,000 * log(100,000)은 약 100,000 * 17로, 매우 빠르게 계산됩니다. 이는 일반적인 코딩 테스트의 시간 제한(보통 1~2초)을 충분히 만족합니다.

---

