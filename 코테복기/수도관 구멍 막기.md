## 수도관 구멍 테이프로 막기

### 📌 문제 설명

* 수도관에 구멍이 `n`개 뚫려 있다.
* 길이가 `tape`인 방수 테이프 하나가 있다.
* 이 테이프를 잘라서 여러 조각으로 사용할 수 있으며,
  길이 `k`짜리 조각은 `[x, x+k-1]` 범위를 덮을 수 있다.
* 모든 구멍을 막기 위해 필요한 **최소 조각 수**를 구하라.

---

### 📌 제약 조건

* `2 <= n <= 100000`
* `1 <= holes[i] <= 100000000`
* `holes`는 오름차순 정렬, 중복 없음
* `1 <= tape <= 100000000`

---

### 📌 예시

| holes           | tape | result |
| --------------- | ---- | ------ |
| \[1,3,8,10,11]  | 8    | 2      |
| \[3,7,17]       | 15   | 1      |
| \[1,6,10]       | 3    | 3      |
| \[1,2,4,5,8,10] | 8    | 2      |

---

### 📌 풀이 아이디어
* **이분탐색**으로 접근한다.
* 판별 함수(isPossible): 주어진 k개의 조각으로 모든 구멍을 막을 수 있는지 확인
* 한 조각씩 가능한 최대 구멍 범위를 덮으며, 테이프 전체 길이를 초과하지 않는지 체크
* 테이프가 부족하면 실패, 모든 구멍을 막으면 성공
* 이렇게 해서 나온 테이프 조각 수가 최소값이다.

---

### 📌 Java 코드

```java
import java.util.Arrays;

class Solution {
    /**
     * 모든 구멍을 막는 데 필요한 최소 테이프 조각 수를 계산합니다.
     *
     * @param holes 구멍의 위치 배열 (오름차순 정렬)
     * @param tape  전체 테이프의 총 길이
     * @return 모든 구멍을 막기 위한 최소 조각 수. 불가능할 경우 -1 반환.
     */
    public int solution(int[] holes, int tape) {
        int n = holes.length;
        int minPieces = -1;

        // 이분 탐색 범위 설정
        // 최소 조각 수는 1개, 최대 조각 수는 구멍의 개수 n개
        int left = 1;
        int right = n;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            // mid개의 조각으로 모든 구멍을 막을 수 있는지 확인
            if (isPossible(mid, holes, tape)) {
                minPieces = mid; // 가능한 경우, 더 적은 조각으로도 가능한지 탐색
                right = mid - 1;
            } else {
                left = mid + 1; // 불가능한 경우, 더 많은 조각이 필요
            }
        }

        return minPieces;
    }

    /**
     * 주어진 k개의 조각으로 모든 구멍을 막을 수 있는지 판단하는 함수
     *
     * @param k     사용할 수 있는 테이프 조각의 개수
     * @param holes 구멍의 위치 배열
     * @param tape  전체 테이프의 총 길이
     * @return 가능 여부 (true/false)
     */
    private boolean isPossible(int k, int[] holes, int tape) {
        // k개의 조각으로 모든 구멍을 막기 위해 필요한 최소 테이프 길이를 계산
        long tapeUsed = 0;
        int currentHoleIndex = 0;
        int n = holes.length;

        for (int i = 0; i < k; i++) {
            if (currentHoleIndex >= n) {
                // 이미 모든 구멍을 막았다면
                return true;
            }

            // 현재 조각의 시작 위치
            int startHoleIndex = currentHoleIndex;
            
            // 현재 조각으로 막을 수 있는 가장 먼 구멍까지 이동
            // 테이프 조각 길이는 (holes[end] - holes[start] + 1)
            int nextHoleIndex = currentHoleIndex + 1;
            while (nextHoleIndex < n) {
                if ((long)holes[nextHoleIndex] - holes[startHoleIndex] + 1 <= tape) {
                    nextHoleIndex++;
                } else {
                    break;
                }
            }
            
            // 이 조각으로 막을 수 있는 가장 먼 구멍은 nextHoleIndex - 1
            int endHoleIndex = nextHoleIndex - 1;
            
            // 사용한 테이프 길이 추가
            tapeUsed += (long)holes[endHoleIndex] - holes[startHoleIndex] + 1;
            
            // 총 테이프 길이를 초과하면 실패
            if (tapeUsed > tape) {
                return false;
            }

            // 다음 조각은 현재 조각이 막지 못한 첫 번째 구멍부터 시작
            currentHoleIndex = nextHoleIndex;
        }

        // k개의 조각으로 모든 구멍을 막았는지 확인
        return currentHoleIndex >= n;
    }
}

```

---

### 📌 시간 복잡도
판별 함수 O(n)
이분 탐색 O(log n)
전체 시간 복잡도 → O(n log n)
n ≤ 100,000, tape ≤ 100,000,000 조건에서 충분히 효율적이다.

---

