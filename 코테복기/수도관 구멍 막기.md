## 수도관 구멍 테이프로 막기

### 📌 문제 설명

* 수도관에 구멍이 `n`개 뚫려 있다.
* 길이가 `tape`인 방수 테이프 하나가 있다.
* 이 테이프를 잘라서 여러 조각으로 사용할 수 있으며,
  길이 `k`짜리 조각은 `[x, x+k-1]` 범위를 덮을 수 있다.
* 모든 구멍을 막기 위해 필요한 **최소 조각 수**를 구하라.

---

### 📌 제약 조건

* `2 <= n <= 100000`
* `1 <= holes[i] <= 100000000`
* `holes`는 오름차순 정렬, 중복 없음
* `1 <= tape <= 100000000`

---

### 📌 예시

| holes           | tape | result |
| --------------- | ---- | ------ |
| \[1,3,8,10,11]  | 8    | 2      |
| \[3,7,17]       | 15   | 1      |
| \[1,6,10]       | 3    | 3      |
| \[1,2,4,5,8,10] | 8    | 2      |

---

### 📌 풀이 아이디어
* **그리디 알고리즘**으로 접근한다.
* 첫 번째 구멍부터 시작해서 테이프 하나를 붙인다.
* 테이프가 덮을 수 있는 범위(`start + tape - 1`)를 계산한다.
* 다음 구멍이 이 범위를 벗어나면 새로운 테이프를 사용한다.
* 이렇게 해서 나온 테이프 조각 수가 최소값이다.

---

### 📌 Java 코드

```java
class Solution {
    public int solution(int[] holes, int tape) {
        int n = holes.length;
        int[][] dp = new int[n + 1][tape + 1];

        // dp 테이블을 무한대로 초기화
        for (int i = 0; i <= n; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[0][0] = 0; // 초기 상태: 구멍 0개를 덮는 데 필요한 조각 수 = 0

        // i번째 구멍까지 덮는데 필요한 최소 조각 수 계산
        for (int i = 1; i <= n; i++) {
            // 테이프 사용 길이 j
            for (int j = 1; j <= tape; j++) {
                // i번째 구멍을 마지막으로 덮는 조각의 시작 위치 p를 고려
                for (int p = 1; p <= i; p++) {
                    int len = holes[i - 1] - holes[p - 1] + 1; // 조각 길이 계산

                    // 테이프 길이 제한 확인 및 이전 상태 유효성 체크
                    if (len <= j && dp[p - 1][j - len] != Integer.MAX_VALUE) {
                        dp[i][j] = Math.min(dp[i][j], dp[p - 1][j - len] + 1);
                    }
                }
            }
        }

        // dp[n][0..tape] 중 최소 조각 수 선택
        int minPieces = Integer.MAX_VALUE;
        for (int j = 0; j <= tape; j++) {
            minPieces = Math.min(minPieces, dp[n][j]);
        }

        return minPieces == Integer.MAX_VALUE ? -1 : minPieces;
    }
}

```

---

### 📌 시간 복잡도
구멍의 수를 n이라 하면, 각 구멍을 한 번씩 순회하면서 테이프 범위를 계산 → O(n)
문제 조건(n ≤ 100,000)에서 충분히 효율적이다.

---

